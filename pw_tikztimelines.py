#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Ignoring warnings about "Used * or ** magic (star-args)"
# pylint: disable=W0142

# Author: Peter Moser <pitiz29a@gmail.com)

r"""TIKZ IMAGE GENERATOR FOR TIMELINE AND TEMPORAL TUPLES

Reads an PostgreSQL (psql --echo-all, see man-page of psql for further details)
output, and creates a standalone TIKZ tex-figure. To configure each output
table or timeline a SQL comment starting with "TIKZ:" must be provided. In
addtion this script needs the following prerequisites for the input:
  1) There must be at least 2 columns for VALID TIME for each table
  2) Each relation must have a TIKZ config line as SQL comment (see below)
  3) A single timeline can be defined with "TIKZ: timeline, from, to, desc"
     This is optional.

We do not use some Python PostgreSQL libs here, because TEMPORAL OPERATORS are
not supported yet. Another reason is that we could create output files manually
if we do not have a running TEMPORAL POSTGRESQL instance running.

TIKZ-comment syntax:
First argument after "TIKZ: " is the type of drawing, currently only relations
and timelines are supported.

-- TIKZ: relation, [abbrev], start column, end column, description
The abbreviation is optional (it is used for tuple names).

-- TIKZ: timeline, from, to, description


For example:
   -- TIKZ: relation, r, ts, te, Input relation r
   TABLE r;
    a | ts | te
   ---+----+----
    B |  1 |  7
    B |  3 |  9
    G |  8 | 10

   -- TIKZ: relation, s, ts, te, Input relation s
   SELECT * FROM s WHERE a='B';
    a | ts | te
   ---+----+----
    B |  2 |  5
    B |  3 |  4
    B |  7 |  9

   -- TIKZ: timeline, 0, 10, time

---------
Changelog
---------
  0.2
      - Reads configs from SQL comments with prefix "-- TIKZ"
      - Checks if TIKZ configs and data input matches
      - Different string formatting techniques tested (just for fun!)
      - Skips SQL commands
  0.1
      - Creates a standalone tikz picture from a PostgreSQL output
      - Skips comments and empty lines
      - Restriction: Hard-coded configuration
"""

import sys
import time
import re
import os

VERSION = 0.2

# State definitions
STATE_OUTSIDE = 0        # We have not found a table yet
STATE_HEADER = 1         # We have found a table header (attribute names)
STATE_TUPLES = 2         # We have already parsed the table header, and are
                         # reading in tuples now

def  tikz_print_top(raw_data):
    """Prints the top of a standalone tikz figure"""
    print "% This file has been automatically generated by..."
    print "%"
    print "%% %s v%s written by Peter Moser <pitiz29a@gmail.com>" % (
            os.path.basename(__file__),
            VERSION)
    print "%"
    print "%% Creation date: %s (YYYY-MM-DD hh:mm:ss)" % (
            time.strftime("%Y-%m-%d %H:%M:%S"))
    print "% From input:"
    print "%% ___________________________________________________" \
          "____________INPUT-START__\n" \
          "%s\n" \
          "%% ___________________________________________________" \
          "____________INPUT-END____\n" % raw_data.strip()
    print r"\documentclass{standalone}"
    print r"\usepackage{tikz}"
    print r"\begin{document}"
    print r"    \begin{tikzpicture}[xscale=0.65,yscale=0.4]"

def  tikz_print_desc(pos, desc):
    """Prints the description of each found table on the left-hand-side of the
    tuple time lines in a standalone tikz figure"""
    string = "\n        %% Description\n" \
             "        \\node[align=left, font=\\scriptsize] " \
             "at (0,{0}) {{{1}}};"
    form = (pos, desc)
    print string.format(*form)


def  tikz_print_line(tup, cfg, tuple_count, count):
    """Prints the tuple time lines in a standalone tikz figure"""
    if cfg['name'] == "":
        string_attribs = "{{$({attribs})$}};"
    else:
        string_attribs = "{{${name}_{{{id}}}=({attribs})$}};"

    string = "\n        %% Tuple {name}_{id}\n" \
             "        \\draw[-] ({ts},{count})--({te},{count});\n" \
             "        \\draw[-] ({posx},{posy}) node[above,font=\\tiny]"

    string += string_attribs

    valid_time_ts = int(tup[cfg['ts']])
    valid_time_te = int(tup[cfg['te']])

    # Concatenate all non-temporal attributes as description above the line
    attribs = ""
    for column in tup:
        if column not in [cfg['ts'], cfg['te']]:
            attribs += r"\mathrm{%s}," % tup[column]

    print string.format(
            name=cfg['name'],
            id=tuple_count,
            ts=valid_time_ts,
            te=valid_time_te,
            count=count,
            posx=float(valid_time_ts+valid_time_te) / 2,
            posy=count - 0.2,
            attribs=attribs.rstrip(','))

def  tikz_print_timeline(cfg):
    """Prints a timeline in a standalone tikz figure"""
    string = r"""
        %% Time line
        \draw[->, line width = 0.9] (%d,0)--(%d,0);
        \foreach \t in {%d,...,%d}
        {
            \draw ($(\t cm,-1mm)+(0cm,0)$)--($(\t cm,1mm)+(0cm,0)$);
            \draw ($(\t cm,0.5mm)$) node[below,font=\scriptsize \bfseries]{\t};
        }
        \draw ($(%d,0)+(3mm,-1mm)$) node[below,font=\bfseries]{$\mathrm{%s}$};
        """

    start = int(cfg['from'])
    end = int(cfg['to'])
    print string % (start,
                      end + 1,
                      start,
                      end,
                      end + 1,
                      cfg['desc'])

def  tikz_print_bottom():
    """Prints the footer of a standalone tikz figure"""
    print "\n   \\end{tikzpicture}\n\\end{document}\n"

def check_key(mylist, key, value):
    """Checks if a key with a certain value exists within a list"""
    return mylist.has_key(key) and mylist[key] == value

def parse():
    """We parse the input read from stdin with a simple state machine"""
    configs = []
    data = []
    raw_data = ""
    configs_timeline_count = 0
    configs_relation_count = 0
    state = STATE_OUTSIDE
    table_count = 0
    for line in sys.stdin:

        raw_data += '% ' + line

        line = line.lstrip()

        # Skip SQL comments (except if they start with the keyword TIKZ)
        if line.startswith('--'):

            # We have found a TIKZ config line
            if state == STATE_OUTSIDE:
                match = re.search(r'--\s*TIKZ:\s(.*)+?', line)
                if match:
                    match = re.split(r'\s*,\s*', match.group(1))
                    if match[0] == 'relation':
                        cfg = {
                            'type': match[0],
                            'name': match[1],
                            'ts': match[2],
                            'te': match[3],
                            'desc': match[4],
                        }
                        configs_relation_count += 1

                    if match[0] == 'timeline':
                        cfg = {
                            'type': match[0],
                            'from': match[1],
                            'to': match[2],
                            'desc': match[3],
                        }
                        configs_timeline_count += 1

                    configs.append(cfg)

                    # We simply ignore incorrect TIKZ config lines, and assume
                    # that they are just normal SQL comments...


            # If we have seen an header line already, this is a table
            # horizontal line which starts tuple lines, i.e., ----+----+-----
            if state == STATE_HEADER:
                state = STATE_TUPLES
            continue

        # Skip empty lines
        # This ends a table parsing, and returns to the outside state
        if line.rstrip() == "":
            if state != STATE_OUTSIDE:
                state = STATE_OUTSIDE
            continue

        # Not skipped and currently in OUTSIDE state, hence it could be a
        # header line, or SQL command. Since we must have at least two temporal
        # columns, we can search for columns delimiters, i.e., |.
        if state == STATE_OUTSIDE:

            # Search for table headers, if none found, skip it...
            match = re.search(r'\s*[^\|]+?\s*\|\s*[^\|]+?', line)
            if match == None:
                continue

            state = STATE_HEADER
            headers = []
            for head in line.split('|'):
                headers.append(head.strip())

            # We need at least two temporal attributes
            if len(headers) < 2:
                print "Parse error: not enough temporal attributes found"
                sys.exit(1)

            data.append([])
            table_count = len(data) - 1

        # Not skipped and currently in a tuple state, therefore the next data
        # line must be another tuple, or tuple count, i.e., (3 rows)
        if state == STATE_TUPLES:

            # We skip tuple count rows at the end of each table. This ends
            # a table block.
            if re.search(r'\(\d+?\srows\)', line):
                state = STATE_OUTSIDE
                continue

            values = []
            for value in line.split('|'):
                values.append(value.strip())
            data[table_count].append(dict(zip(headers, values)))

    # Now lets make some integrity checks:
    # 1) Do we have enough config strings for all tables?
    # 2) Do we have zero or one timeline string, but not more?
    if configs_relation_count != len(data):
        print "ERROR: We do not have enough TIKZ relation config strings"
        print "HINT : Define a configuration string for each table.\n" \
              "       For example:\n" \
              "       -- TIKZ: relation, table_name, ts, te, relation " \
              "description"
        sys.exit(3)

    if configs_timeline_count > 1:
        print "ERROR: More than one TIKZ timeline string found"
        print "HINT : Define a single configuration string for the "\
              "timeline.\n" \
              "       For example:\n" \
              "       -- TIKZ: timeline, from, to, time line description"
        sys.exit(3)

    return {'configs': configs,
            'data': data,
            'raw_data': raw_data,}

def main():
    """Main, nothing more to say :-)"""

    result = parse()

    raw_data = result['raw_data']
    data = result['data']
    configs = result['configs']

    ###########################################################################
    # GENERATOR
    #
    # Now we have read the input, it is time to generate valid TIKZ output.

    # Count tuples above the timeline. We do this, because we need to count
    # backwards while creating lines above the timeline. However, it is not
    # necessary below, because there we count starting from 1, s.t., the
    # index 1 is always close to the timeline in the middle.
    count_above = 0
    i = 0
    for dat in data:
        if check_key(configs[i], 'type', 'timeline'):
            break
        count_above += len(dat)
        i += 1

    tikz_print_top(raw_data)

    timeline_printed = False
    count = count_above

    # We use the config-list as stack, therefore we must reverse it first...
    configs.reverse()

    for table in data:

        cfg = configs.pop()

        # Print the timeline
        if check_key(cfg, 'type', 'timeline'):
            tikz_print_timeline(cfg)
            timeline_printed = True
            cfg = configs.pop()
            count = -2

        # Print description on the left-hand-side of each relation
        if cfg['desc'].strip() != "":
            tikz_print_desc(count - len(table) / 2 + 0.5, cfg['desc'])

        # After a timeline, the tuple count must not be reversed again, s.t.,
        # the tuple with index 1 is the closest to the timeline.
        if timeline_printed:
            tuple_count = 1
        else:
            tuple_count = len(table)
            table = reversed(table)

        for tup in table:
            tikz_print_line(tup, cfg, tuple_count, count)

            count -= 1

            if timeline_printed:
                tuple_count += 1
            else:
                tuple_count -= 1

    # All data has been printed already, maybe we can find something inside the
    # configuration array that has not been printed yet...
    for cfg in configs:

        # Print the timeline
        if check_key(cfg, 'type', 'timeline'):
            tikz_print_timeline(cfg)


    tikz_print_bottom()

if __name__ == '__main__':
    main()
