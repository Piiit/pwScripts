#!/usr/bin/env python
# -*- coding: utf-8 -*-
# _____________________________________________________________________________
#
#           TIKZ IMAGE GENERATOR FOR TIMELINE AND TEMPORAL TUPLES 
#               (written by Peter Moser <pitiz29a@gmail.com)
# _____________________________________________________________________________
#
# Input dictionary, read from stdin, format is default PostgreSQL output. We
# have the following prerequisites for the input:
#   1) There must be at least 2 columns for VALID TIME
#   2) Each relation must have a TIKZ config line as SQL comment (see below)
#   3) A single timeline can be defined with "TIKZ: timeline, from, to, desc"
# For example:
#    -- TIKZ: relation, r, ts, te, Input relation r
#     a | ts | te
#    ---+----+----
#     B |  1 |  7
#     B |  3 |  9
#     G |  8 | 10
#    
#    -- TIKZ: relation, s, ts, te, Input relation s
#     a | ts | te
#    ---+----+----
#     B |  2 |  5
#     B |  3 |  4
#     B |  7 |  9
#     
#    -- TIKZ: timeline, 0, 10, time
#
# ---------
# Changelog
# ---------
#   0.2
#       - Reads configs from SQL comments with prefix "-- TIKZ"
#       - Checks if TIKZ configs and data input matches
#       - Different string formatting techniques tested (just for fun!)
#   0.1
#       - Creates a standalone tikz picture from a PostgreSQL output
#       - Skips comments and empty lines
#       - Restriction: Hard-coded configuration

import sys
import time
import re
import os

VERSION = 0.2

def printTIKZTop(rawData):
    print "% This file has been automatically generated by..."
    print "%% Tool name: %s (written by Peter Moser <pitiz29a@gmail.com>)" % (
            os.path.basename(__file__))
    print "%% Tool version: %s" % VERSION
    print "%% Creation date: %s (YYYY-MM-DD hh:mm:ss)" % (
            time.strftime("%Y-%m-%d %H:%M:%S"))
    print "% From input:"
    print "%% ___________________________________________________" \
          "____________INPUT-START__\n" \
          "%s\n" \
          "%% ___________________________________________________" \
          "____________INPUT-END____\n" % rawData.strip()
    print r"\documentclass{standalone}"
    print r"\usepackage{tikz}"
    print r"\begin{document}"
    print r"    \begin{tikzpicture}[xscale=0.65,yscale=0.4]"
    
def printTIKZDesc(pos, desc):
    string = "\n        %% Description\n" \
             "        \\node[align=left, font=\\scriptsize] " \
             "at (0,{0}) {{{1}}};"
    format = (pos, desc)
    print string.format(*format)
        
        
def printTIKZLine(t, cfg, tupleCount, count):
    if cfg['name'] == "":
        stringAttribs = "{{$({attribs})$}};"
    else:
        stringAttribs = "{{${name}_{{{id}}}=({attribs})$}};"
        
    string = "\n        %% Tuple {name}_{id}\n" \
             "        \\draw[-] ({ts},{count})--({te},{count});\n" \
             "        \\draw[-] ({posx},{posy}) node[above,font=\\tiny]" 
             
    string += stringAttribs
        
    ts = int(t[cfg['ts']])
    te = int(t[cfg['te']])

    # Concatenate all non-temporal attributes as description above the line
    attribs = ""
    for d in t:
        if d not in [cfg['ts'], cfg['te']]:
            attribs += r"\mathrm{%s}," % t[d]
            
    print string.format(
            name = cfg['name'],
            id = tupleCount,
            ts = ts,
            te = te,
            count = count,
            posx = float(ts+te) / 2,
            posy = count - 0.2,
            attribs = attribs.rstrip(','))

def printTIKZTimeline(cfg):
    string = r"""
        %% Time line
        \draw[->, line width = 0.9] (%d,0)--(%d,0);
        \foreach \t in {%d,...,%d}
        {
            \draw ($(\t cm,-1mm)+(0cm,0)$)--($(\t cm,1mm)+(0cm,0)$);
            \draw ($(\t cm,0.5mm)$) node[below,font=\scriptsize \bfseries]{\t};
        }
        \draw ($(%d,0)+(3mm,-1mm)$) node[below,font=\bfseries]{$\mathrm{%s}$};
        """
        
    fr = int(cfg['from'])
    to = int(cfg['to'])
    print string % (fr, 
                      to + 1, 
                      fr, 
                      to, 
                      to + 1, 
                      cfg['desc'])
           
def printTIKZBottom():
    print "\n   \\end{tikzpicture}\n\\end{document}\n"

def checkKey(list, key, value):
    return list.has_key(key) and list[key] == value
    
def main():
    ###############################################################################
    # PARSER
    #
    # We parse the input read from stdin with a simple state machine
    
    # State definitions
    STATE_OUTSIDE = 0       # We have not found a table yet
    STATE_HEADER = 1        # We have found a table header (attribute names)
    STATE_TUPLES = 2        # We have already parsed the table header, and are
                            # reading in tuples now
    
    configsTimelineCount = 0
    configsRelationCount = 0
    configs = []
    rawData = ""
    data = []
    state = STATE_OUTSIDE
    c = 0
    for line in sys.stdin:
        
        rawData += '% ' + line
        
        line = line.lstrip()
    
        # Skip SQL comments (except if they start with the keyword TIKZ)
        if line.startswith('--'):
            
            # We have found a TIKZ config line
            if state == STATE_OUTSIDE:
                m = re.search('\s*--\s*TIKZ:\s(.*)+?', line)
                if m:
                    m = re.split('\s*,\s*', m.group(1))
                    if m[0] == 'relation':
                        cfg = {
                            'type': m[0],
                            'name': m[1],
                            'ts': m[2],
                            'te': m[3],
                            'desc': m[4],
                        }
                        configsRelationCount += 1
                    
                    if m[0] == 'timeline':
                        cfg = {
                            'type': m[0],
                            'from': m[1],
                            'to': m[2],
                            'desc': m[3],
                        }
                        configsTimelineCount += 1
                        
                    configs.append(cfg)
                    
                    # We simply ignore incorrect TIKZ config lines, and assume
                    # that they are just normal SQL comments...
                    
                
            # If we have seen an header line already, this is a table horizontal 
            # line which starts tuple lines, i.e., ----+----+-----
            if state == STATE_HEADER:
                state = STATE_TUPLES
            continue
    
        # Skip empty lines
        # This ends a table parsing, and returns to the outside state
        if line.rstrip() == "":
            if state != STATE_OUTSIDE:
                state = STATE_OUTSIDE
            continue
    
        # Not skipped and currently in OUTSIDE state, hence it must be a header 
        # line.
        if state == STATE_OUTSIDE:
            state = STATE_HEADER
            headers = []
            for head in line.split('|'):
                headers.append(head.strip())
    
            # We need at least two temporal attributes
            if len(headers) < 2:
                print "Parse error: not enough temporal attributes found"
                sys.exit(1)
    
            data.append([])
            c = len(data) - 1
    
        # Not skipped and currently in a tuple state, therefore the next data  
        # line must be another tuple.
        if state == STATE_TUPLES:
            values = []
            for v in line.split('|'):
                values.append(v.strip())
            data[c].append(dict(zip(headers, values)))
            
    ###############################################################################
    # SYNTAX AND SEMANTIC CHECKS
    #
    # Now lets make some integrity checks:
    # 1) Do we have enough config strings for all tables?
    # 2) Do we have zero or one timeline string, but not more?
    if configsRelationCount != len(data):
        print "ERROR: We do not have enough TIKZ relation config strings"
        print "HINT : Define a configuration string for each table.\n" \
              "       For example:\n" \
              "       -- TIKZ: relation, table_name, ts, te, relation description"
        sys.exit(3)
        
    if configsTimelineCount > 1:
        print "ERROR: More than one TIKZ timeline string found"
        print "HINT : Define a single configuration string for the timeline.\n" \
              "       For example:\n" \
              "       -- TIKZ: timeline, from, to, time line description"
        sys.exit(3)   
            
            
    ###############################################################################
    # GENERATOR
    #
    # Now we have read the input, it is time to generate valid TIKZ output.
    
    # Count tuples above the timeline. We do this, because we need to count
    # backwards while creating lines above the timeline. However, it is not
    # necessary below, because there we count starting from 1, s.t., the index 1
    # is always close to the timeline in the middle.
    tableCount = 0
    countAbove = 0
    i = 0
    for d in data:
        if checkKey(configs[i], 'type', 'timeline'):
            break
        countAbove += len(d)
        i += 1
    
    printTIKZTop(rawData)
    
    tableCount = 0
    timelinePrinted = False
    count = countAbove
    
    # We use the configuration list as stack, therefore we must reverse it first...
    configs.reverse()
    
    for table in data:
    
        cfg = configs.pop()
        
        # Print the timeline
        if checkKey(cfg, 'type', 'timeline'):
            printTIKZTimeline(cfg)
            timelinePrinted = True
            cfg = configs.pop()
            count = -2
            
        # Print description on the left-hand-side of each relation
        if cfg['desc'].strip() != "":
            printTIKZDesc(count - len(table) / 2 + 0.5, cfg['desc'])    
    
        # After a timeline, the tuple count must not be reversed again, s.t., the 
        # tuple with index 1 is the closest to the timeline.
        if timelinePrinted:
            tupleCount = 1
        else:
            tupleCount = len(table)
            table = reversed(table)
    
        tableCount += 1
        
        for t in table:
            printTIKZLine(t, cfg, tupleCount, count)
            
            count -= 1
    
            if timelinePrinted:
                tupleCount += 1
            else:
                tupleCount -= 1
    
    # All data has been printed already, maybe we can find something inside the 
    # configuration array that has not been printed yet...
    for cfg in configs:
    
        # Print the timeline
        if checkKey(cfg, 'type', 'timeline'):
            printTIKZTimeline(cfg)
    
    
    printTIKZBottom()

if __name__ == '__main__':
	main()